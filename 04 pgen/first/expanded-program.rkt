(λ (in)
  (define lex (lexer in))
  (define cur (lex))
  (define (report expected got)
    (error 'parse-error expected ~s, but got ~s expected got))
  (define (take) (let ((old cur)) (set! cur (lex)) old))
  (define (expect-op-and $$)
    (unless (op-and? cur) (report $$ cur))
    (set-token-pos! $$ (token-pos cur))
    (set-token-text! $$ (token-text cur))
    (take))
  (define (parse-C1 $$)
    (case (object-name cur)
      ((op-mul)
       (let* (($1 (Op1 '())) ($2 (E1 '())))
         (let-syntax (($$* (λ (_) #'(C1 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(Op1 (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2* (λ (_) #'(E1 (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2*)))
             (parse-Op1 $1)
             (parse-E1 $2)
             (delay $$)))))
      (else
       (let* ()
         (let-syntax (($$* (λ (_) #'(C1 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$)))))
           (begin (set-node-children! $$ (delay '())) (delay $$)))))))
  (define (expect-op-or $$)
    (unless (op-or? cur) (report $$ cur))
    (set-token-pos! $$ (token-pos cur))
    (set-token-text! $$ (token-text cur))
    (take))
  (define (parse-Un $$)
    (case (object-name cur)
      ((op-neg)
       (let* (($1 (op-neg '() '())))
         (let-syntax (($$* (λ (_) #'(Un (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1*
                       (λ (_)
                         #'(op-neg
                            (force (token-pos $1))
                            (force (token-text $1)))))
                      ($1-pos* (λ (_) #'(force (token-pos $1))))
                      ($1-text* (λ (_) #'(force (token-text $1)))))
           (begin
             (set-node-children! $$ (delay $1*))
             (expect-op-neg $1)
             (delay $$)))))
      (else (report $$ cur))))
  (define (parse-C4 $$)
    (case (object-name cur)
      ((op-xor)
       (let* (($1 (Op4 '())) ($2 (E4 '())))
         (let-syntax (($$* (λ (_) #'(C4 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(Op4 (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2* (λ (_) #'(E4 (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2*)))
             (parse-Op4 $1)
             (parse-E4 $2)
             (delay $$)))))
      (else
       (let* ()
         (let-syntax (($$* (λ (_) #'(C4 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$)))))
           (begin (set-node-children! $$ (delay '())) (delay $$)))))))
  (define (parse-Op5 $$)
    (case (object-name cur)
      ((op-or)
       (let* (($1 (op-or '() '())))
         (let-syntax (($$* (λ (_) #'(Op5 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1*
                       (λ (_)
                         #'(op-or
                            (force (token-pos $1))
                            (force (token-text $1)))))
                      ($1-pos* (λ (_) #'(force (token-pos $1))))
                      ($1-text* (λ (_) #'(force (token-text $1)))))
           (begin
             (set-node-children! $$ (delay $1*))
             (expect-op-or $1)
             (delay $$)))))
      (else (report $$ cur))))
  (define (parse-Pr $$)
    (case (object-name cur)
      ((op-neg)
       (let* (($1 (Un '())) ($2 (Pr '())))
         (let-syntax (($$* (λ (_) #'(Pr (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(Un (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2* (λ (_) #'(Pr (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2*)))
             (parse-Un $1)
             (parse-Pr $2)
             (delay $$)))))
      ((open-paren)
       (let* (($1 (open-paren '() '()))
              ($2 (E '()))
              ($3 (close-paren '() '())))
         (let-syntax (($$* (λ (_) #'(Pr (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1*
                       (λ (_)
                         #'(open-paren
                            (force (token-pos $1))
                            (force (token-text $1)))))
                      ($1-pos* (λ (_) #'(force (token-pos $1))))
                      ($1-text* (λ (_) #'(force (token-text $1))))
                      ($2* (λ (_) #'(E (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2))))
                      ($3*
                       (λ (_)
                         #'(close-paren
                            (force (token-pos $3))
                            (force (token-text $3)))))
                      ($3-pos* (λ (_) #'(force (token-pos $3))))
                      ($3-text* (λ (_) #'(force (token-text $3)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2* $3*)))
             (expect-open-paren $1)
             (parse-E $2)
             (expect-close-paren $3)
             (delay $$)))))
      ((variable)
       (let* (($1 (variable '() '())))
         (let-syntax (($$* (λ (_) #'(Pr (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1*
                       (λ (_)
                         #'(variable
                            (force (token-pos $1))
                            (force (token-text $1)))))
                      ($1-pos* (λ (_) #'(force (token-pos $1))))
                      ($1-text* (λ (_) #'(force (token-text $1)))))
           (begin
             (set-node-children! $$ (delay $1*))
             (expect-variable $1)
             (delay $$)))))
      (else (report $$ cur))))
  (define (parse-E3 $$)
    (case (object-name cur)
      ((variable op-neg open-paren)
       (let* (($1 (E2 '())) ($2 (C3 '())))
         (let-syntax (($$* (λ (_) #'(E3 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(E2 (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2* (λ (_) #'(C3 (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2*)))
             (parse-E2 $1)
             (parse-C3 $2)
             (delay $$)))))
      (else (report $$ cur))))
  (define (expect-close-paren $$)
    (unless (close-paren? cur) (report $$ cur))
    (set-token-pos! $$ (token-pos cur))
    (set-token-text! $$ (token-text cur))
    (take))
  (define (parse-E5 $$)
    (case (object-name cur)
      ((variable op-neg open-paren)
       (let* (($1 (E4 '())) ($2 (C5 '())))
         (let-syntax (($$* (λ (_) #'(E5 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(E4 (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2* (λ (_) #'(C5 (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2*)))
             (parse-E4 $1)
             (parse-C5 $2)
             (delay $$)))))
      (else (report $$ cur))))
  (define (parse-Op2 $$)
    (case (object-name cur)
      ((op-plus)
       (let* (($1 (op-plus '() '())))
         (let-syntax (($$* (λ (_) #'(Op2 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1*
                       (λ (_)
                         #'(op-plus
                            (force (token-pos $1))
                            (force (token-text $1)))))
                      ($1-pos* (λ (_) #'(force (token-pos $1))))
                      ($1-text* (λ (_) #'(force (token-text $1)))))
           (begin
             (set-node-children! $$ (delay $1*))
             (expect-op-plus $1)
             (delay $$)))))
      (else (report $$ cur))))
  (define (parse-C2 $$)
    (case (object-name cur)
      ((op-plus)
       (let* (($1 (Op2 '())) ($2 (E2 '())))
         (let-syntax (($$* (λ (_) #'(C2 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(Op2 (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2* (λ (_) #'(E2 (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2*)))
             (parse-Op2 $1)
             (parse-E2 $2)
             (delay $$)))))
      (else
       (let* ()
         (let-syntax (($$* (λ (_) #'(C2 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$)))))
           (begin (set-node-children! $$ (delay '())) (delay $$)))))))
  (define (expect-op-neg $$)
    (unless (op-neg? cur) (report $$ cur))
    (set-token-pos! $$ (token-pos cur))
    (set-token-text! $$ (token-text cur))
    (take))
  (define (parse-E1 $$)
    (case (object-name cur)
      ((variable op-neg open-paren)
       (let* (($1 (Pr '())) ($2 (C1 '())))
         (let-syntax (($$* (λ (_) #'(E1 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(Pr (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2* (λ (_) #'(C1 (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2*)))
             (parse-Pr $1)
             (parse-C1 $2)
             (delay $$)))))
      (else (report $$ cur))))
  (define (parse-Op1 $$)
    (case (object-name cur)
      ((op-mul)
       (let* (($1 (op-mul '() '())))
         (let-syntax (($$* (λ (_) #'(Op1 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1*
                       (λ (_)
                         #'(op-mul
                            (force (token-pos $1))
                            (force (token-text $1)))))
                      ($1-pos* (λ (_) #'(force (token-pos $1))))
                      ($1-text* (λ (_) #'(force (token-text $1)))))
           (begin
             (set-node-children! $$ (delay $1*))
             (expect-op-mul $1)
             (delay $$)))))
      (else (report $$ cur))))
  (define (expect-open-paren $$)
    (unless (open-paren? cur) (report $$ cur))
    (set-token-pos! $$ (token-pos cur))
    (set-token-text! $$ (token-text cur))
    (take))
  (define (expect-variable $$)
    (unless (variable? cur) (report $$ cur))
    (set-token-pos! $$ (token-pos cur))
    (set-token-text! $$ (token-text cur))
    (take))
  (define (parse-Op4 $$)
    (case (object-name cur)
      ((op-xor)
       (let* (($1 (op-xor '() '())))
         (let-syntax (($$* (λ (_) #'(Op4 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1*
                       (λ (_)
                         #'(op-xor
                            (force (token-pos $1))
                            (force (token-text $1)))))
                      ($1-pos* (λ (_) #'(force (token-pos $1))))
                      ($1-text* (λ (_) #'(force (token-text $1)))))
           (begin
             (set-node-children! $$ (delay $1*))
             (expect-op-xor $1)
             (delay $$)))))
      (else (report $$ cur))))
  (define (parse-E $$)
    (case (object-name cur)
      ((variable op-neg open-paren)
       (let* (($1 (E5 '())))
         (let-syntax (($$* (λ (_) #'(E (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(E5 (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1)))))
           (begin
             (set-node-children! $$ (delay $1*))
             (parse-E5 $1)
             (delay $$)))))
      (else (report $$ cur))))
  (define (expect-op-plus $$)
    (unless (op-plus? cur) (report $$ cur))
    (set-token-pos! $$ (token-pos cur))
    (set-token-text! $$ (token-text cur))
    (take))
  (define (parse-C5 $$)
    (case (object-name cur)
      ((op-or)
       (let* (($1 (Op5 '())) ($2 (E5 '())))
         (let-syntax (($$* (λ (_) #'(C5 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(Op5 (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2* (λ (_) #'(E5 (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2*)))
             (parse-Op5 $1)
             (parse-E5 $2)
             (delay $$)))))
      (else
       (let* ()
         (let-syntax (($$* (λ (_) #'(C5 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$)))))
           (begin (set-node-children! $$ (delay '())) (delay $$)))))))
  (define (parse-C3 $$)
    (case (object-name cur)
      ((op-and)
       (let* (($1 (Op3 '())) ($2 (E3 '())))
         (let-syntax (($$* (λ (_) #'(C3 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(Op3 (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2* (λ (_) #'(E3 (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2*)))
             (parse-Op3 $1)
             (parse-E3 $2)
             (delay $$)))))
      (else
       (let* ()
         (let-syntax (($$* (λ (_) #'(C3 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$)))))
           (begin (set-node-children! $$ (delay '())) (delay $$)))))))
  (define (expect-end-of-input $$)
    (unless (end-of-input? cur) (report $$ cur))
    (set-token-pos! $$ (token-pos cur))
    (set-token-text! $$ (token-text cur))
    (take))
  (define (parse-parse-result $$)
    (case (object-name cur)
      ((variable op-neg open-paren)
       (let* (($1 (E '())) ($2 (end-of-input '() '())))
         (let-syntax (($$*
                       (λ (_)
                         #'(parse-result (force (parse-result-value $$)))))
                      ($$-value* (λ (_) #'(force (parse-result-value $$))))
                      ($1* (λ (_) #'(E (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2*
                       (λ (_)
                         #'(end-of-input
                            (force (token-pos $2))
                            (force (token-text $2)))))
                      ($2-pos* (λ (_) #'(force (token-pos $2))))
                      ($2-text* (λ (_) #'(force (token-text $2)))))
           (begin
             (set-parse-result-value! $$ (delay $1*))
             (parse-E $1)
             (expect-end-of-input $2)
             (delay $$)))))
      (else (report $$ cur))))
  (define (parse-E4 $$)
    (case (object-name cur)
      ((variable op-neg open-paren)
       (let* (($1 (E3 '())) ($2 (C4 '())))
         (let-syntax (($$* (λ (_) #'(E4 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(E3 (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2* (λ (_) #'(C4 (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2*)))
             (parse-E3 $1)
             (parse-C4 $2)
             (delay $$)))))
      (else (report $$ cur))))
  (define (parse-E2 $$)
    (case (object-name cur)
      ((variable op-neg open-paren)
       (let* (($1 (E1 '())) ($2 (C2 '())))
         (let-syntax (($$* (λ (_) #'(E2 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1* (λ (_) #'(E1 (force (node-children $1)))))
                      ($1-children* (λ (_) #'(force (node-children $1))))
                      ($2* (λ (_) #'(C2 (force (node-children $2)))))
                      ($2-children* (λ (_) #'(force (node-children $2)))))
           (begin
             (set-node-children! $$ (delay (list $1* $2*)))
             (parse-E1 $1)
             (parse-C2 $2)
             (delay $$)))))
      (else (report $$ cur))))
  (define (expect-op-xor $$)
    (unless (op-xor? cur) (report $$ cur))
    (set-token-pos! $$ (token-pos cur))
    (set-token-text! $$ (token-text cur))
    (take))
  (define (parse-Op3 $$)
    (case (object-name cur)
      ((op-and)
       (let* (($1 (op-and '() '())))
         (let-syntax (($$* (λ (_) #'(Op3 (force (node-children $$)))))
                      ($$-children* (λ (_) #'(force (node-children $$))))
                      ($1*
                       (λ (_)
                         #'(op-and
                            (force (token-pos $1))
                            (force (token-text $1)))))
                      ($1-pos* (λ (_) #'(force (token-pos $1))))
                      ($1-text* (λ (_) #'(force (token-text $1)))))
           (begin
             (set-node-children! $$ (delay $1*))
             (expect-op-and $1)
             (delay $$)))))
      (else (report $$ cur))))
  (define (expect-op-mul $$)
    (unless (op-mul? cur) (report $$ cur))
    (set-token-pos! $$ (token-pos cur))
    (set-token-text! $$ (token-text cur))
    (take))
  (define (as-values result)
    (define fres (force result))
    (values (force (parse-result-value fres))))
  (as-values (parse-parse-result (parse-result '()))))
