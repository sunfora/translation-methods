#lang racket

;;
;; TODO:
;; 1. делаем first follow для грамматики
;;    верифицируем на примере из первой лабы
;; 2. придумываем запись для нашего парсера
;; 3. будем делать LL(1) грамматику (10 баллов)
;;    с пробросом контекста 
;;    (наследуемыми + синтезируемыми атрибутами)  (10 баллов)
;;                                                (10 баллов)
;; 4. генерируем (возможно с помощью макроса результат)
;; 5.0 делаем калькулятор (но это моя вторая лаба)  (10 баллов)
;; 5.1 делаем первую лабу                           (5 баллов)
;;
;; итого вроде ожидаю чот на уровне 45 баллов
;; и надо будет написать report в котором всё это я покажу
;;
;; времени не очень много, я хотел бы конечно потыкать LALR и генерить бинарники какие-нибудь
;; управляющие таблички и всё такое
;; но я дурачок и всё зафакапил как всегда, так что забейте
;;

'{
  [tokens (operator [[priority :: 1 .. 3] action])
          (variable [name value])
          (number   [value])
          (paren    [kind :: '("(" ")")])]
  [nterms (expr     [[priority :: 0 .. 3] value])
          (cont     [acum [priority :: 1 .. 3] value])]
  
  [grammar (expr 3 .value)
    [(expr 0 value) {
      (paren "(") (expr 3 .value) (paren ")")
    }]
    [(expr 0 value) {
      (number .value)
    }]
    [(expr 0 value) {
      (variable)
      (ε (begin 
           (display "found variable! yey!")
           (read))
         .value)
    }]

    [(expr .i value) {
     (expr (- i 1) .v) (cont v i .value)
    }]

    [(cont .acc .i r) {
     (operator i .a) (expr (- i 1) .e) (cont (a acc e) i .r)
    }]
    [(cont .v _ v) {}]
  ]
}

;; потом мы должны убрать всё что не является параметрами
;; параметры с непараметрами мешаться не должны иначе жопа
;;
;; ну в том смысле что параметры грамматики могут участвовать 
;; в непараметрах
;;
;; а непараметры в параметрах грамматики не должны быть
;;
;; и надо собрать все уникальные значения
;;
;; мы начинаем с самой топовой формы
;; кладём её в хешмапу
;;
;; и идём пытаемся заматчить все правила что существуют
;; мы матчим примерно так: 
;;    1. если у нас есть значение то мы должны мэтчить точку
;;       либо мы видим штуку которая метчится по значению
;;
;;    2. если у нас есть точка то мы должны метчить значение
;; 
;; плейсхолдер (типа не важно) подходит и тем и тем
;; если у нас есть значение, то мы создаём новое правило с этой фигнёй
;; на месте плейсхолдера
;;
;; если у нас точка, то мы генерируем все виды правил
;;
;; вычисления идут слева на право
;; сверху вниз, ну и так далее
;;
'[grammar (expr 3 _)
  [(expr 0 _) {
    (paren "(") (expr 3 _) (paren ")")
  }]
  [(expr 0 _) {
    (number _)
  }]
  [(expr 0 _) {
    (variable _ _)
    (ε _ _)
  }]
  [(expr .i _) {
   (expr (- i 1) _) (cont _ i _)
  }]

  [(cont _ .i _) {
   (operator i _) (expr (- i 1) _) (cont _ i _)
  }]
  [(cont _ _ _) {(ε _ _)}]
]

;; то есть что-то такое получается
'{
  (expr 3 _)
  (expr 2 _)
  (expr 1 _)
  (expr 0 _)
  (paren "(")
  (paren ")")
  (number _)
  (variable _ _)
  (ε _ _)
  (cont _ 1 _)
  (cont _ 2 _)
  (cont _ 3 _)
}

;; нагенерировать всевозможные вариации правил
;;
;; проверить что получившееся говно является LL(1)
;; надо посчитать first и follow

;; в общем пока не важно завтра сделаем

;; если есть какие-то проблемы то выводим это автору грамматики
;; если нет приступаем к генерации

;; для этого опять таки идём с самого верху (по обычным правилам!)
;; и начинаем генерировать соответствующие функции
;; будем просто нумеровать правила
;; и генерировать типа
;; 
;; (parse-expr/1 ...)
;; (parse-expr/2 ...)
;;
;; в принципе кажись я могу написать первый парсер 
;; (без вычисления грамматики) перед вторым с вычислением
;;
;; и уже можно будет потихоньку закрывать лабу
;;
;; типа начинаем мы со штуки есть (expr 3 _) 
;; 
;; мы должны посмотреть чо там за правило
;; там будет что-то вроде 
;;
;; (expr 2 _) (cont _ 3 _)
;; 
;; мы пишем чот вот такое
;; (define (parse in)
;;    (define $$ (expr 3 _))
;;    (parse-expr/1 $$))
;;
;; (define (parse-expr/1 $$)
;;   (define $1 (expr 2 _))
;;   (define $2 (cont _ 3 _))
;;   (parse-expr/2 $1)
;;   (set-cont-arg! $2 (expr-value $1))
;;   (parse-cont/1 $2)
;;   (set-expr-value! $$ (cont-value $2)))
;;
;; (define (parse-expr/2 $$)
;; 
;;  
;;
;; (define parse-expr-3 
;;      ...)
;;
;; ну и так далее
;;
;; ну и всё вроде
;; надо еще правила с токенами разобрать или чот такое
;;
;; теперь надо просто это сделать
;; потом добавить генерацию правил 
;; и сгенерировать две домашки
;;
;; о боже
;;
;; ну да ладно
;; поехали

(struct parser-token () #:transparent
                        #:mutable)
(require (for-syntax syntax/free-vars))
(define-syntax (test stx)
  (define x (local-expand stx 'expression #f))
  (display (free-vars x))
  #'(display "ok"))

(struct parser-thunk (calc )

  (free-vars
